import { Time } from './time';
import DeepState from 'deep-state-observer';
import { DataChartTime, ScrollTypeHorizontal, Row, Item, Vido, Items, ScrollTypeVertical, Rows, GridCell, GridRows, GridRow, GridCells, DataItems, ItemData, ItemDataUpdate, ColumnData, RowData, RowsData, ItemDataPosition, DataChartTimeLevels, TreeMap } from '../gstc';
import { generateSlots } from './slots';
export declare const mergeDeep: typeof import("@neuronet.io/vido/types/helpers").mergeDeep;
export declare function getClass(name: string, appendix?: string): string;
export declare function getId(name: string, id: string): string;
export interface WheelResult {
    x: number;
    y: number;
    z: number;
    event: WheelEvent;
}
export interface IconsCache {
    [key: string]: string;
}
export declare type Unsubscribes = (() => void)[];
export declare class Api {
    name: string;
    debug: boolean;
    state: DeepState;
    time: Time;
    vido: Vido;
    plugins: any;
    pluginsPositions: Set<string>;
    iconsCache: IconsCache;
    unsubscribes: Unsubscribes;
    private mutedMethods;
    generateSlots: typeof generateSlots;
    mergeDeep: typeof import("@neuronet.io/vido/types/helpers").mergeDeep;
    getClass: typeof getClass;
    getId: typeof getId;
    GSTCID: (originalId: string) => string;
    isGSTCID: (id: string) => boolean;
    sourceID: (id: string) => string;
    allActions: any[];
    main: any;
    constructor(state: DeepState);
    render(): Promise<unknown>;
    getListenerPosition(callback: any): string | number;
    setVido(Vido: Vido): void;
    log(...args: any[]): void;
    pluginInitialized(pluginName: string): void;
    pluginDestroyed(pluginName: string): void;
    clearPluginsPositions(): void;
    isPluginInitialized(pluginName: string): boolean;
    getPluginPosition(pluginName?: string): number;
    getPluginsPositions(): {};
    isPluginInitializedBefore(pluginName: string, beforePluginName: string): boolean;
    getActions(name: string): any;
    isItemInViewport(item: Item, leftGlobal?: number, rightGlobal?: number): boolean;
    private getChildrenLinkedItemsIds;
    collectAllLinkedItems(items: Items, itemsData: DataItems): void;
    getChildrenDependantItemsIds(item: Item, items: Items, allDependant?: string[]): string[];
    calculateItemVerticalPosition(itemId: string, itemData?: ItemData, rowData?: RowData): ItemDataPosition;
    calculateItemHorizontalPosition(itemId: string, itemData?: ItemData, rowData?: RowData, time?: DataChartTime, spacing?: any): ItemDataPosition;
    calculateItemPosition(itemId: string, itemData?: ItemData, rowData?: RowData, time?: DataChartTime, spacing?: any): ItemDataPosition;
    getItemPosition(itemId: string, itemData?: ItemData, rowData?: RowData, time?: DataChartTime, spacing?: any): ItemDataPosition;
    getRow(rowId: string): Row;
    getRows(rowsId: string[]): Row[];
    getAllRows(): Rows;
    getVisibleRowsId(): string[];
    getRowsData(): RowsData;
    setRowsData(data: RowsData): void;
    getRowData(rowId: string): RowData;
    setRowData(rowId: string, data: RowData): void;
    getItem(itemId: string): Item;
    getItems(itemsId?: string[]): Item[];
    getAllItems(): Items;
    getItemData(itemId: string): ItemData;
    getItemsData(): DataItems;
    setItemData(itemId: string, data: ItemDataUpdate): void;
    setItemsData(data: DataItems): void;
    prepareDependantItems(item: Item, items: Items): string[];
    prepareItem(item: Item, defaultItemHeight?: number, itemsData?: DataItems, items?: Items): void;
    prepareItems(items: Items): Items;
    sortRows(sortedRowsArray: Row[], children: TreeMap[], rows?: Rows): Rows;
    fillEmptyRowValues(rows: Rows): Rows;
    itemsOnTheSameLevel(item1: Item, item2: Item): boolean;
    itemsOverlaps(item1: Item, item2: Item): boolean;
    itemOverlapsWithOthers(item: Item, items: Item[]): Item;
    fixOverlappedItems(rowItems: Item[]): void;
    recalculateRowHeight(row: Row, rowData: RowData): number;
    recalculateRowsHeights(rowsId?: string[]): number;
    recalculateRowsPercents(rowsId: string[], verticalAreaHeight: number): void;
    calculateVisibleRowsHeights(): void;
    generateParents(rows: RowsData | Items, parentName?: string): {};
    fastTree(rowParents: any, node: any, parents?: any[]): any;
    makeRowsTree(rowsData: RowsData, rowsTreeNode: any): any;
    makeTreeMap(rowsData: RowsData, items: Items, onlyItems?: boolean): void;
    getRowsWithParentsExpanded(rows: Rows): any[];
    getVisibleRowsAndCalculateViewTop(): string[];
    private getSortableValue;
    sortRowsByColumn(column: ColumnData, asc?: boolean): Rows;
    normalizeMouseWheelEvent(event: WheelEvent): WheelResult;
    scrollToTime(toTime: number, centered?: boolean, time?: DataChartTime): number;
    setScrollLeft(dataIndex: number | undefined, time?: DataChartTime, multi?: any, recalculateTimesLastReason?: string): any;
    getScrollLeft(): ScrollTypeHorizontal;
    setScrollTop(dataIndex: number | undefined, offset?: number): void;
    getScrollTop(): ScrollTypeVertical;
    getCurrentCalendarLevels(): DataChartTimeLevels;
    getGridCells(cellIds?: string[]): GridCell[];
    getAllGridCells(): GridCells;
    getGridRows(rowIds?: string[]): GridRow[];
    getAllGridRows(): GridRows;
    getGridCell(cellId: string): GridCell;
    getGridRow(rowId: string): GridRow;
    muteMethod(methodName: string): void;
    unmuteMethod(methodName: string): void;
    isMutedMethod(methodName: string): boolean;
    getSVGIconSrc(svg: any): string;
    destroy(): void;
}
//# sourceMappingURL=api.d.ts.map