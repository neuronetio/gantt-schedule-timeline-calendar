!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).ItemMovement={})}(this,(function(t){"use strict";const e="chart-timeline-items-row-item";const i="config.plugin.ItemMovement";class a{constructor(t,e){this.onDestroy=[],this.scrollWaiting=0,this.vido=t,this.state=t.state,this.api=t.api,this.data=function(t={}){const e={onStart:({items:t})=>t.after,onMove:({items:t})=>t.after,onEnd:({items:t})=>t.after},i={start:({startTime:t,time:e})=>t.startOf(e.period)},a={speed:{horizontal:1,vertical:1},edgeThreshold:{horizontal:50,vertical:0}},s=Object.assign({enabled:!0,dependant:!0,debug:!1,state:"",bodyClass:"gstc-items-moving",itemClass:"",movement:{x:0,y:0,time:0},threshold:{horizontal:10,vertical:10},initialItems:[],initialDependant:[],initialItemsData:{},initialDependantData:{},isMoving:!1,events:Object.assign({},e),snapToTime:Object.assign({},i),autoScroll:Object.assign({},a)},t);return t.snapToTime&&(s.snapToTime=Object.assign(Object.assign({},i),t.snapToTime)),t.events&&(s.events=Object.assign(Object.assign({},e),t.events)),t.autoScroll&&(s.autoScroll=Object.assign(Object.assign({},a),t.autoScroll),t.autoScroll.edgeThreshold&&(s.autoScroll.edgeThreshold=Object.assign(Object.assign({},a.edgeThreshold),t.autoScroll.edgeThreshold)),t.autoScroll.speed&&(s.autoScroll.speed=Object.assign(Object.assign({},a.speed),t.autoScroll.speed))),s}(e),this.data.itemClass||(this.data.itemClass=this.api.getClass("timeline-chart-items-row-item")+"--moving"),this.destroy=this.destroy.bind(this),this.itemUpdateAction=this.itemUpdateAction.bind(this),this.onDestroy.push(this.state.subscribe("$data.elements.chart-timeline",(t=>this.timelineElement=t))),this.updateData(),this.onDestroy.push(this.state.subscribe("config.plugin.ItemMovement",(t=>{t.enabled&&t.isMoving?document.body.classList.add(t.bodyClass):document.body.classList.remove(t.bodyClass),this.data=t}))),this.onPointerMove=this.onPointerMove.bind(this),this.onPointerUp=this.onPointerUp.bind(this),this.onDestroy.push(this.state.subscribe("config.plugin.TimelinePointer",(t=>{this.pointerData=t,this.onPointerData()})))}destroy(){this.onDestroy.forEach((t=>t())),this.api.pluginDestroyed("ItemMovement")}updateData(){this.state.update(i,this.data)}getSelectedItems(){return this.state.get(`config.plugin.Selection.selected.${e}`).map((t=>this.api.mergeDeep({},this.api.getItem(t))))}getSelectedItemsData(t){const e={};for(const i of t)e[i.id]=this.api.mergeDeep({},this.api.getItemData(i.id));return e}getEventArgument(t){const e=this.api.getAllItems(),i=[];for(const a of t)i.push(this.api.mergeDeep({},e[a.id]));return{items:{initial:this.data.initialItems,before:i,after:t,targetData:this.pointerData.targetData},vido:this.vido,state:this.state,time:this.state.get("$data.chart.time")}}getDependantItems(){const t=[],e=this.api.getItemsData();for(const i of this.data.initialItems)for(const a of e[i.id].dependant)t.includes(a)||t.push(a);const i=this.state.get("config.chart.items");return t.map((t=>i[t])).map((t=>this.api.mergeDeep({},t)))}getDependantItemsData(){const t={},e=this.api.getItemsData();for(const i of this.data.initialDependant)t[i.id]=this.api.mergeDeep({},e[i.id]);return t}moveDependantItems(t,e){if(!this.data.dependant)return e;const i=this.api.getItemsData(),a=this.state.get("config.chart.time");for(const s of t){const t=this.data.initialItems.find((t=>t.id===s.id)),o=this.data.initialItemsData[t.id],n=i[s.id];if(n.dependant.length)for(const t of n.dependant){const i=this.data.initialDependant.find((e=>e.id===t)),s=this.data.initialDependantData[t],l=n.time.endDate.diff(o.time.endDate,"millisecond"),d=s.time.startDate.add(l,"millisecond"),h=s.time.endDate.add(l,"millisecond"),r=n.position.right-s.position.right,c=n.position.viewTop-s.position.viewTop,p=this.data.snapToTime.start({startTime:d,item:this.api.mergeDeep({},i),time:a,movement:{x:r,y:c,time:l},vido:this.vido});e=e.update(`config.chart.items.${t}.time`,(t=>(t.start=p.valueOf(),t.end=h.valueOf(),t))),e=e.update(`$data.chart.items.${t}.time`,(t=>(t.startDate=p,t.endDate=h,t)))}}return e}dispatchEvent(t,e,i=null){"onStart"===t&&(this.api.muteMethod("fixOverlapped"),this.api.muteMethod("fullReload"),this.api.muteMethod("recalculateRowPercents"),this.api.muteMethod("getLastPageRowsHeight"),this.api.muteMethod("calculateVerticalScrollArea"),this.api.muteMethod("heightChange"),this.api.muteMethod("calculateRowsHeight"),this.api.muteMethod("minimalReload"),0===this.data.autoScroll.speed.horizontal&&0===this.data.autoScroll.speed.vertical&&(this.api.muteMethod("generateVisibleRowsAndItems"),this.api.muteMethod("calculateVisibleRowsHeights"),this.api.muteMethod("prepareExpanded"),this.api.muteMethod("recalculateTimes"))),"onEnd"===t&&(this.api.unmuteMethod("fixOverlapped"),this.api.unmuteMethod("heightChange"),this.api.unmuteMethod("calculateVerticalScrollArea"),this.api.unmuteMethod("getLastPageRowsHeight"),this.api.unmuteMethod("recalculateRowPercents"),this.api.unmuteMethod("fullReload"),this.api.unmuteMethod("calculateRowsHeight"),this.api.unmuteMethod("minimalReload"),0===this.data.autoScroll.speed.horizontal&&0===this.data.autoScroll.speed.vertical&&(this.api.unmuteMethod("generateVisibleRowsAndItems"),this.api.unmuteMethod("calculateVisibleRowsHeights"),this.api.unmuteMethod("prepareExpanded"),this.api.unmuteMethod("recalculateTimes"))),e=e.map((t=>this.api.mergeDeep({},t)));const a=this.data.events[t](this.getEventArgument(e));let s=this.state.multi();const o=this.state.get("config.chart.items");for(const t of a){const e=o[t.id];s=s.update(`config.chart.items.${t.id}.time`,t.time),e.rowId!==t.rowId&&(s=s.update(`config.chart.items.${t.id}.rowId`,t.rowId)),i&&(s=s.update(`$data.chart.items.${t.id}`,i[t.id]))}"onStart"!==t&&"onMove"!==t||(s=this.moveDependantItems(a,s)),s.done(),this.api.main.updateVisibleItems().done()}getItemsForDiff(){const t=this.getSelectedItems()[0],e=this.data.initialItems.find((e=>e.id===t.id));return{modified:t,original:e}}onPointerData(){this.data.enabled&&("down"===this.pointerData.pointerState&&this.pointerData.targetType===e?this.api.plugins.TimelinePointer.isLocked("down")||this.triggerDown():"move"===this.pointerData.pointerState&&this.pointerData.targetType===e?"item-movement"===this.api.plugins.TimelinePointer.isLocked("move")&&this.onPointerMove():"up"===this.pointerData.pointerState&&this.pointerData.targetType===e&&"item-movement"===this.api.plugins.TimelinePointer.isLocked("up")&&this.onPointerUp())}triggerDown(){document.body.classList.add(this.data.bodyClass),this.api.plugins.TimelinePointer.lock("down","item-movement"),this.api.plugins.TimelinePointer.lock("move","item-movement"),this.api.plugins.TimelinePointer.lock("up","item-movement"),this.data.isMoving=!0,this.data.initialItems=this.getSelectedItems(),this.data.initialDependant=this.getDependantItems(),this.data.initialItemsData=this.getSelectedItemsData(this.data.initialItems),this.data.initialDependantData=this.getDependantItemsData(),""!==this.data.state&&"end"!==this.data.state||(this.data.state="move"),this.dispatchEvent("onStart",this.data.initialItems),this.updateData()}moveItemVertically(t,e){const i=this.data.movement.y,a=this.data.initialItemsData[t.id],s=this.api.getVisibleRowsId(),o=this.api.getRowsData();for(let n=0,l=s.length;n<l;n++){const d=s[n],h=o[d];let r=a.position.viewTop+i;if(r<0&&(r=0),r<=h.position.viewTop||n+1===l){t.rowId=d,e.position.viewTop=h.position.viewTop,e.position.rowTop=0;break}}}scrollLeft(){if(this.data.autoScroll.speed.horizontal){if(this.scrollWaiting++,this.data.autoScroll.speed.horizontal<0){if(this.scrollWaiting-1<Math.abs(this.data.autoScroll.speed.horizontal))return;const t=this.api.getScrollLeft();this.api.setScrollLeft(t.dataIndex-1)}else if(this.data.autoScroll.speed.horizontal>0){const t=this.api.getScrollLeft();this.api.setScrollLeft(t.dataIndex-this.data.autoScroll.speed.horizontal)}this.scrollWaiting=0}}scrollRight(){if(this.data.autoScroll.speed.horizontal){if(this.scrollWaiting++,this.data.autoScroll.speed.horizontal<0){if(this.scrollWaiting-1<Math.abs(this.data.autoScroll.speed.horizontal))return;const t=this.api.getScrollLeft();this.api.setScrollLeft(t.dataIndex+1)}else if(this.data.autoScroll.speed.horizontal>0){const t=this.api.getScrollLeft();this.api.setScrollLeft(t.dataIndex+this.data.autoScroll.speed.horizontal)}this.scrollWaiting=0}}scrollTop(){if(this.data.autoScroll.speed.vertical){if(this.scrollWaiting++,this.data.autoScroll.speed.vertical<0){if(this.scrollWaiting-1<Math.abs(this.data.autoScroll.speed.vertical))return;const t=this.api.getScrollTop();this.api.setScrollTop(t.dataIndex-1)}else if(this.data.autoScroll.speed.vertical>0){const t=this.api.getScrollTop();this.api.setScrollTop(t.dataIndex-this.data.autoScroll.speed.vertical)}this.scrollWaiting=0}}scrollBottom(){if(this.data.autoScroll.speed.vertical){if(this.scrollWaiting++,this.data.autoScroll.speed.vertical<0){if(this.scrollWaiting-1<Math.abs(this.data.autoScroll.speed.vertical))return;const t=this.api.getScrollTop();this.api.setScrollTop(t.dataIndex+1)}else if(this.data.autoScroll.speed.vertical>0){const t=this.api.getScrollTop();this.api.setScrollTop(t.dataIndex+this.data.autoScroll.speed.vertical)}this.scrollWaiting=0}}autoScroll(){if(!this.timelineElement)return;const t=this.pointerData.currentPosition.x,e=this.pointerData.currentPosition.y,i=this.timelineElement.getBoundingClientRect();t<this.data.autoScroll.edgeThreshold.horizontal?this.scrollLeft():t>i.width-this.data.autoScroll.edgeThreshold.horizontal?this.scrollRight():e<this.data.autoScroll.edgeThreshold.vertical?this.scrollTop():e>i.height-this.data.autoScroll.edgeThreshold.vertical&&this.scrollBottom()}onPointerMove(){if(!this.data.enabled)return;if(!this.data.isMoving)return;const{original:t,modified:e}=this.getItemsForDiff();if(!t)return;const i=this.data.movement=Object.assign(Object.assign({},this.pointerData.movement),{time:e.time.start-t.time.start});"move"!==this.data.state&&"start"!==this.data.state||(this.data.state="move");const a=this.getSelectedItems(),s={},o=this.state.get("$data.chart.time");for(let t=0,e=a.length;t<e;t++){const e=a[t],n=this.api.mergeDeep({},this.data.initialItemsData[e.id]);this.moveItemVertically(e,n);const l=n.time.endDate.diff(n.time.startDate,"millisecond");n.position.left=n.position.left+i.x;const d=this.api.time.getTimeFromViewOffsetPx(n.position.left,o,!0),h=this.data.snapToTime.start({startTime:this.api.time.date(d),item:e,time:o,movement:i,vido:this.vido}),r=h.add(l,"millisecond");e.time.start=h.valueOf(),e.time.end=r.valueOf(),n.time.startDate=h,n.time.endDate=r,n.position.right=n.position.left+n.width,s[e.id]=n}this.dispatchEvent("onMove",a,s),this.autoScroll(),this.updateData()}onEnd(){const t=this.getSelectedItems();this.dispatchEvent("onEnd",t)}onPointerUp(){document.body.classList.remove(this.data.bodyClass),this.data.enabled&&this.data.isMoving&&("move"===this.data.state&&(this.data.state="end"),this.data.isMoving=!1,this.onEnd(),this.updateData(),this.api.plugins.TimelinePointer.unlock("down"),this.api.plugins.TimelinePointer.unlock("move"),this.api.plugins.TimelinePointer.unlock("up"))}itemUpdateAction(t,e){this.data.initialItems.find((t=>t.id===e.item.id))&&this.data.isMoving?t.classList.add(this.data.itemClass):t.classList.remove(this.data.itemClass)}}t.Plugin=function(t={}){return function(e){const s=e.api;if(!s.isPluginInitialized("TimelinePointer"))throw new Error("TimelinePointer plugin must be initialized before ItemMovement plugin.");if(!s.isPluginInitialized("Selection"))throw new Error("Selection plugin must be initialized before ItemMovement plugin.");const o=e.state.get(i);o&&(t=e.api.mergeDeep({},t,o));const n=new a(e,t);return s.pluginInitialized("ItemMovement"),n.destroy}},Object.defineProperty(t,"__esModule",{value:!0})}));
