/**
 * Gantt-Schedule-Timeline-Calendar helpers
 *
 * @copyright NEURONET - Rafal Pospiech
 * @author    Rafal Pospiech <neuronet.io@gmail.com>
 * @module    gantt-schedule-timeline-calendar
 * @link      https://github.com/neuronetio/gantt-schedule-timeline-calendar
 * @link      https://gantt-schedule-timeline-calendar.neuronet.io
 * @version   3.35.5
 * @released  2024-05-06
 * @license   SEE LICENSE IN LICENSE FILE
 */
const t="gstc";
/**
 * TimeBookmarks plugin
 *
 * @copyright NEURONET - Rafal Pospiech
 * @author    Rafal Pospiech <neuronet.io@gmail.com>
 * @module    gantt-schedule-timeline-calendar
 * @link      https://github.com/neuronetio/gantt-schedule-timeline-calendar
 * @link      https://gantt-schedule-timeline-calendar.neuronet.io
 * @version   3.35.5
 * @released  2024-05-06
 * @license   SEE LICENSE IN LICENSE FILE
 */
const s="config.plugin.TimeBookmarks",e="config.slots.chart-timeline-items.outer";class i{constructor(i,a){this.unsub=[],this.options=function(t){return Object.assign({enabled:!0,className:""},t)}(i),this.vido=a,this.state=a.state,this.className=function(s,e=""){let i=`${t}__${s}`;return s===t&&(i=t),e?`${i} ${i}--${e.replace(":","-")}`:i}("chart-time-bookmark")+(this.options.className?` ${this.options.className}`:""),this.PluginTimeBookmarksSlot=this.PluginTimeBookmarksSlot.bind(this),this.destroy=this.destroy.bind(this),this.state.update(s,this.options),this.state.update(e,(t=>(t.includes(this.PluginTimeBookmarksSlot)||t.push(this.PluginTimeBookmarksSlot),t))),this.unsub.push(this.state.subscribe(s,(t=>this.options=t)))}destroy(){this.unsub.forEach((t=>t())),this.state.update(e,(t=>t.filter((t=>t!==this.PluginTimeBookmarksSlot)))),this.vido.api.pluginDestroyed("TimeBookmarks")}PluginTimeBookmarksSlot(t){const{html:e,onDestroy:i,state:a,update:l,api:o,StyleMap:n}=t,c=[];i(a.subscribeAll([s,"$data.chart.time","$data.scroll.horizontal.dataIndex"],(()=>{var t;const e=a.get("$data.chart.time"),i=a.get(s);c.length=0;for(const s in i.bookmarks){const a=o.time.date(i.bookmarks[s].time);if(!o.time.isInCurrentView(a,e))continue;const l=Object.assign(Object.assign({},i.bookmarks[s]),{id:s,leftViewPx:0,absoluteLeftPx:0,visible:!1,date:null,styleMap:new n(Object.assign(null!==(t=i.bookmarks[s].style)&&void 0!==t?t:{},{left:"",height:""}))});l.styleMap.style.background=l.styleMap.style.background||l.color||"#3498DB",l.id=s,l.date=a,l.leftViewPx=o.time.getViewOffsetPxFromDates(a,!1,e),l.absoluteLeftPx=o.time.getGlobalOffsetPxFromDates(l.date,!1,e),l.visible=l.absoluteLeftPx>=e.leftPx&&l.absoluteLeftPx<=e.rightPx,c.push(l)}l()}),{group:!0}));let r=0,h=0;i(a.subscribe("$data.scroll.vertical",(t=>{r=Math.round(o.getRealChartHeight()),h=Math.round(-t.preciseOffset),l()})));const m=t=>e`<div
        class="${this.className}-line ${this.className}-line--${t.id}${t.className?` ${t.className}`:""}"
        style="left:${t.leftViewPx}px;top: ${h}px;"
      >
        <div
          class="${this.className}-line-content ${this.className}-line-content--${t.id}"
          style="border-left: 1px solid ${t.styleMap.style.background};"
        ></div>
      </div>`,d=t=>e`<div
        class="${this.className}-label ${this.className}-label--${t.id}${t.className?` ${t.className}`:""}"
        style="left:${t.leftViewPx}px;top: ${h}px;"
      >
        <div
          class="${this.className}-label-content ${this.className}-label-content--${t.id}"
          style=${t.styleMap.directive()}
        >
          ${t.label}
        </div>
      </div>`;return t=>e`<div class="${this.className}s ${this.className}s--lines" style="height: ${r}px;">
          ${c.filter((t=>t.visible)).map((t=>m(t)))}
        </div>
        ${t}
        <div class="${this.className}s ${this.className}s--labels" style="height: ${r}px;">
          ${c.filter((t=>t.visible)).map((t=>d(t)))}
        </div>`}}function a(t={}){return function(e){const a=e.state.get(s);a&&(t=e.api.mergeDeep({},t,a));const l=new i(t,e);return e.api.pluginInitialized("TimeBookmarks"),l.destroy}}export{a as Plugin,s as pluginPath,e as slotPath};